# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PhotogrammetyToolsDockWidget
                                 A QGIS plugin
 A plugin for manage photogrammetry projects
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-04-05
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Universidad de Castilla-La Mancha
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys,os
import logging
from osgeo import osr
from decimal import Decimal
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo, QDir, QObject
from PyQt5.QtWidgets import QMessageBox, QFileDialog, QTabWidget, QInputDialog, QLineEdit, QAction, QDockWidget
from qgis.core import QgsApplication, QgsDataSourceUri, QgsProject
# pluginPath = 'python/plugins/photogrammetry_tools'
# pluginPath = os.path.join(QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path(), pluginPath)
# libCppPath = os.path.join(pluginPath, 'libCpp')
# existsPluginPath = QDir(libCppPath).exists()
# sys.path.append(pluginPath)
# sys.path.append(libCppPath)
# os.environ["PATH"] += os.pathsep + libCppPath
# from libCpp.libPyPhotogrammetryTools import IPyPhotogrammetryToolsProject
# from multipleFileSelectorDialog.multiple_file_selector_dialog import * #panel nueva camara
# # from processListEditionDialog.process_list_edition_dialog import *
# import PTDefinitions
# #  dhl

from .multipleFileSelectorDialog.multiple_file_selector_dialog import * #panel nueva camara
# import MMTDefinitions
from . import PTDefinitions
#  dhl

import os

from math import floor
import re

from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal,QSettings
from PyQt5.QtWidgets import QTextEdit,QPushButton,QVBoxLayout

from .ui.ui_phtools_images_widget import PhToolsQImagesWidget
from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal
from qgis.gui import QgsMapToolDigitizeFeature, QgsMapMouseEvent, QgsAdvancedDigitizingDockWidget, QgsMapToolPan, \
    QgsMapToolEmitPoint
from .highlightFeature import HighlightFeature

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'photogrammetry_tools_dockwidget_base.ui'))


class QgsPhToolEditVertex(QgsMapToolEmitPoint):
    def __init__(self, canvas):
        self.canvas = canvas
        super(QgsMapToolEmitPoint, self).__init__(self.canvas)



class QgsPhToolDigitizeFeature(QgsMapToolDigitizeFeature):
    canvasPressSignal = pyqtSignal(QgsMapMouseEvent)

    def __init__(self, canvas, cdw):
        self.canvas = canvas
        self.cdw = cdw
        super(QgsPhToolDigitizeFeature, self).__init__(self.canvas, self.cdw)
        # self.canvasPressSignal.connect(self.onCanvasPressSignal)

    # def canvasPressEvent(self, e: QgsMapMouseEvent):
    #     # e.ignore()
    #     # self.canvasPressSignal.emit(e)
    #     # self.canvasPressSignal.emit(e.mapPoint())
    #     if self.mode() == 1:  # CapturePoint
    #         import pydevd_pycharm
    #         pydevd_pycharm.settrace('localhost', port=54100, stdoutToServer=True, stderrToServer=True)
    #         points = self.points()
    #         layer = self.currentVectorLayer()
    #         pass
    #     pass

    def canvasReleaseEvent(self, e: QgsMapMouseEvent):
        super().cadCanvasReleaseEvent(e)
        # import pydevd_pycharm
        # pydevd_pycharm.settrace('localhost', port=54100, stdoutToServer=True, stderrToServer=True)
        # if self.mode() == 1:  # CapturePoint
        #     points = self.points()
        #     layer = self.currentVectorLayer()
        #     feature_count = layer.featureCount()
        #     features = layer.getFeatures()
        #     pass
        self.canvasPressSignal.emit(e)

class QgsPhToolPan(QgsMapToolPan):
    canvasPressSignal = pyqtSignal(QgsPointXY)

    def __init__(self, canvas):
        self.canvas = canvas
        super(QgsMapToolPan, self).__init__(self.canvas)

class PhotogrammetyToolsDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,
                 iface,
                 pluginPath,
                 libCppPath,
                 currentPluginName,
                 settings,
                 iPyProject,
                 pt_qt_project,
                 parent=None):
        """Constructor."""
        super(PhotogrammetyToolsDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setWindowTitle(PTDefinitions.CONST_PROGRAM_NAME)
        self.iface = iface
        self.path_plugin = pluginPath
        self.path_libCpp = libCppPath
        self.current_plugin_name = currentPluginName
        self.settings = settings
        self.iPyProject = iPyProject
        self.pt_qt_project = pt_qt_project
        self.selectedFeature = None
        self.isPTPlugin = False
        if self.current_plugin_name == PTDefinitions.CONST_SETTINGS_PLUGIN_NAME:
            self.isPTPlugin = True
        self.setupUi(self)
        self.initialize()

    def addImageFiles(self):
        dbFileName = self.connections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        if len(self.imageFiles) == 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select image files before")
            msgBox.exec_()
            return
        strImageFiles = ''
        cont = 0
        for imageFile in self.imageFiles:
            if cont > 0:
                strImageFiles = strImageFiles + self.parametersFromPythonStringSeparator
            strImageFiles = strImageFiles + imageFile
            cont = cont + 1
        ret = self.iPyProject.ptAddImageFilesToProject(dbFileName,
                                                       strImageFiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        ret = self.iPyProject.ptGetNumberOfImages(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.numberOfImagesInProject = ret[1]
        if self.numberOfImagesInProject > 0:
            self.importOriGroupBox.setEnabled(True)
            self.importUndistortedImagesGroupBox.setEnabled(True)
        return

    def addToProjectFromMetashapeMarkersXmlFile(self):
        dbFileName = self.connections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        # if len(self.imageFiles)==0:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("There are no images in project. Import image files before")
        #     msgBox.exec_()
        #     return
        metashapeProjectMarkersXmlFile = None
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            metashapeProjectMarkersXmlFile = self.metashapeFileMpLineEdit.text()
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            metashapeProjectMarkersXmlFile = self.metashapeFileLineEdit.text()
        if not metashapeProjectMarkersXmlFile:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Metashape Project Markers XML file before")
            msgBox.exec_()
            return
        code = None
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            code = self.metashapeCodeMpLineEdit.text()
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            code = self.metashapeCodeLineEdit.text()
        if not code:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select code before")
            msgBox.exec_()
            return
        # chunk = self.metashapeChunkLineEdit.text()
        # if not chunk:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Select Metashape chunk before")
        #     msgBox.exec_()
        #     return
        chunk = None
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            chunk = self.metashapeChunkMpComboBox.currentText()
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            chunk = self.metashapeChunkComboBox.currentText()
        if chunk == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Metashape chunk before")
            msgBox.exec_()
            return
        self.existsOrientations = False
        self.processingToolsPage.setEnabled(False)
        ret = self.iPyProject.ptAddToProjectFromMetashapeMarkersXmlFile(dbFileName,
                                                                        metashapeProjectMarkersXmlFile,
                                                                        chunk,
                                                                        code)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        ret = self.iPyProject.ptGetExistsOrientations(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.existsOrientations = ret[1]
        if self.existsOrientations:
            self.processingToolsPage.setEnabled(True)
            self.loadImagesPcLayer()
        self.iface.zoomToActiveLayer()
        self.iface.mapCanvas().refresh()
        return

    def addUndistortedImageFiles(self):
        dbFileName = self.connections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        if len(self.undistortedImageFiles) == 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select undistorted image files before")
            msgBox.exec_()
            return
        strImageFiles = ''
        cont = 0
        for imageFile in self.undistortedImageFiles:
            if cont > 0:
                strImageFiles = strImageFiles + self.parametersFromPythonStringSeparator
            strImageFiles = strImageFiles + imageFile
            cont = cont + 1
        ret = self.iPyProject.ptAddUndistortedImageFilesToProject(dbFileName,
                                                                  strImageFiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        return

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def closeProject(self):
        if not self.dbFileName:
            return
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        # delete project in ram??
        root = QgsProject.instance().layerTreeRoot()
        self.removeGroup(root,self.layerTreeProjectName)
        self.dbFileName = None
        self.layerTreeProjectName = None
        self.layerTreeProject = None
        self.layerTreePCTilesName = None
        self.layerTreePCTiles = None
        self.projectsComboBox.setEnabled(True)
        self.projectsComboBox.setCurrentIndex(0)
        self.iface.mapCanvas().refresh()
        # self.manualEditingProcessesPage.setEnabled(False)
        return

    def createProject(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type")
            msgBox.exec_()
            return
        strGridSize = self.gridSizeComboBox.currentText()
        if strGridSize == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type")
            msgBox.exec_()
            return
        gridSize = Decimal(strGridSize)
        crs = self.projectQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            return
        altitudeIsMsl = True
        if self.projectAltitudeEllipsoidRadioButton.isChecked():
            altitudeIsMsl = False
        dbFileName = self.databaseLineEdit.text()
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strRoisShapefiles = ''
        cont = 0
        for roiShapefile in self.roisShapefiles:
            if cont > 0:
                strRoisShapefiles = strRoisShapefiles + self.parametersFromPythonStringSeparator
            strRoisShapefiles = strRoisShapefiles + roiShapefile
            cont = cont + 1
        ret = self.iPyProject.ptCreateProject(dbFileName,
                                              projectType,
                                              strGridSize,  #gridSize,
                                              crsEpsgCode,
                                              altitudeIsMsl,
                                              strRoisShapefiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        connectionName = QFileInfo(dbFileName).fileName()
        con = [connectionName, dbFileName]
        QSettings().setValue("SpatiaLite/connections/%s/sqlitepath" % (con[0]), con[1])
        self.iface.reloadConnections()
        self.getSpatialiteConnections()
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Process completed successfully")
        msgBox.exec_()
        return

    def getProcessingToolsCommands(self):
        ret = self.iPyProject.ptGetProcessingToolsCommands()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        processingToolsCommands = []
        cont = 0
        for value in ret:
            if cont > 0:
                processingToolsCommands.append(value)
            cont = cont + 1
        self.processingToolsCommandComboBox.clear()
        self.processingToolsCommandComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
        for command in processingToolsCommands:
            self.processingToolsCommandComboBox.addItem(command)
        return

    def getSpatialiteConnections(self):
        self.connections = {}
        settings = QSettings()
        settings.beginGroup('/SpatiaLite/connections')
        list_str_keys = settings.allKeys()
        paths = []
        for key in list_str_keys:
            if key!= 'selected':
                paths.append(settings.value(key))
        ret = self.iPyProject.getPhotogrammetrySpatialiteDbs(paths)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.pmOuptutPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        connectionNames = settings.childGroups()
        cont = 0
        for connectionName in connectionNames:
            path = paths[cont]
            if path in ret:
                self.connections[connectionName] = paths[cont]
            cont = cont + 1
        self.projectsComboBox.clear()
        self.projectsComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
        for connection in self.connections.keys():
            self.projectsComboBox.addItem(connection)
        return

    def initialize(self):
        yo = 1
        self.enableMeasurements = False

        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        self.projectType = None
        self.windowTitle = PTDefinitions.CONST_PROGRAM_NAME

        qs = QSettings()

        # template path que cuelga del directorio de este fichero
        pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
        thisFilePath = os.path.dirname(os.path.realpath(__file__))
        thisFilePath = os.path.join(pluginsPath, thisFilePath)
        # templatePath = os.path.join(thisFilePath, PCTDefinitions.CONST_TEMPLATE_PATH)
        self.templatePath = thisFilePath + PTDefinitions.CONST_TEMPLATE_PATH
        svg_paths = qs.value('svg/searchPathsForSVG')
        # if self.templatePath not in svg_paths:
        #     qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])
        qs.setValue('svg/searchPathsForSVG', self.templatePath)

        # self.qmlPointCloudFileName = self.templatePath + PCTDefinitions.CONST_SYMBOLOGY_POINT_CLOUD_TEMPLATE
        self.qmlTilesFileName = self.templatePath + PTDefinitions.CONST_SYMBOLOGY_TILES_TEMPLATE
        self.qmlRoisFileName = self.templatePath + PTDefinitions.CONST_SYMBOLOGY_ROIS_TEMPLATE
        self.qmlImagesPcFileName = self.templatePath + PTDefinitions.CONST_SYMBOLOGY_IMAGES_PC

        self.path = self.settings.value("last_path")
        if not self.path:
            self.path = QDir.currentPath()
            self.settings.setValue("last_path",self.path)
            self.settings.sync()

        self.projectManagerTemporalPath = self.settings.value("project_management_temporal_path")
        auxDir = QDir(self.path)
        if not self.projectManagerTemporalPath or not auxDir.exists(self.projectManagerTemporalPath):
            self.projectManagerTemporalPath = self.path_libCpp + PTDefinitions.CONST_PROJECT_MANAGEMENT_TEMPORAL_PATH
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
        self.pmTemporalPathLineEdit.setText(self.projectManagerTemporalPath)

        self.projectManagerOutputPath = self.settings.value("project_management_output_path")
        auxDir = QDir(self.path)
        if not self.projectManagerOutputPath or not auxDir.exists(self.projectManagerOutputPath):
            self.projectManagerOutputPath = self.path_libCpp + PTDefinitions.CONST_PROJECT_MANAGEMENT_OUTPUT_PATH
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
        self.pmOutputPathLineEdit.setText(self.projectManagerOutputPath)

        self.outputPath = self.settings.value("output_path")
        if not self.outputPath or not auxDir.exists(self.outputPath):
            self.outputPath = self.path_libCpp + PTDefinitions.CONST_PROJECT_MANAGEMENT_OUTPUT_PATH
            self.settings.setValue("output_path", self.outputPath)
            self.settings.sync()
        self.pmOutputPathLineEdit.setText(self.outputPath)

        self.roisShapefiles = []
        self.roisFileTypes = []
        self.roisFileTypes.append(PTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        self.roisFilesActiveFileExtensions = self.roisFileTypes
        self.imageFiles = []
        self.undistortedImageFiles = []
        self.existsOrientations = False
        self.imageFilesFileTypes = []
        self.imageFilesFileTypes.append(PTDefinitions.CONST_DOCUMENTS_TYPE_JPG)
        self.imageFilesFileTypes.append(PTDefinitions.CONST_DOCUMENTS_TYPE_TIF)
        self.imageFilesFileTypes.append(PTDefinitions.CONST_DOCUMENTS_TYPE_TIFF)
        # self.pointCloudFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.imageFilesActiveFileExtensions = self.imageFilesFileTypes
        self.numberOfImagesInProject=0

        spatialiteConnections = qs.value("SpatiaLite/connections")
        # self.iPyProject=IPyPCTProject()
        self.parametersFromPythonStringSeparator = self.iPyProject.getParametersFromPythonStringSeparator()
        ret = self.iPyProject.setPhotogrammetryManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        ret = self.iPyProject.ptSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        ret = self.iPyProject.ptSetProjectManagerOutputPath(self.projectManagerOutputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmOutputPathLineEdit.setText("")
            self.projectManagerOutputPath = None
            return

        self.layerTreeProject = None
        self.layerTreeProjectName = None
        self.layerTreePCTiles = None
        self.layerTreePCTilesName = None
        self.image_paths = None
        self.loadedTiles = []

        # set projectManagement active
        self.photogrammetryToolBox.setCurrentIndex(0)
        # self.photogrammetryToolBox.currentChanged.connect(self.onModelManagementToolBoxChanged)
        self.processingToolsPage.setEnabled(False)


        ###################################################
        # Project Management Page
        ###################################################
        # Projects spatialite databases
        self.getSpatialiteConnections()
        self.projectsComboBox.currentIndexChanged.connect(self.selectProject)

        # Project
        self.openProjectPushButton.clicked.connect(self.openProject)
        self.closeProjectPushButton.clicked.connect(self.closeProject)

        # Project types
        self.projecTypes = self.iPyProject.ptGetProjectTypes()
        if len(self.projecTypes) > 1:
            self.projectTypeComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
        for projectType in self.projecTypes:
            self.projectTypeComboBox.addItem(projectType)
        self.projectTypeComboBox.currentIndexChanged.connect(self.selectProjectType)
        if len(self.projecTypes) == 1:
            self.projectTypeComboBox.setEnabled(False)

        # Grid sizes
        gridSizes = self.iPyProject.ptGetGridSizes()
        self.gridSizeComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
        for gridSize in gridSizes:
            strGridSize = str(round(gridSize, PTDefinitions.CONST_GRID_SIZE_ACCURACY))
            self.gridSizeComboBox.addItem(strGridSize)

        # Parameters
        self.projectParametersPushButton.clicked.connect(self.selectProjectParameters)

        # DbFile
        self.databasePushButton.clicked.connect(self.selectNewDatabase)

        self.projectManagementTabWidget.setTabEnabled(0,True)
        self.projectManagementTabWidget.setTabEnabled(1,False)
        self.projectManagementTabWidget.setTabEnabled(2,False)
        self.projectManagementTabWidget.setCurrentIndex(0)
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)

        # ROIs
        self.roisPushButton.clicked.connect(self.selectRois)
        self.numberOfRoisLineEdit.setText("0")

        # Images
        self.selectImagesPushButton.clicked.connect(self.selectImages)
        self.numberOfImagesLineEdit.setText("0")
        self.addImagesProcessPushButton.clicked.connect(self.addImageFiles)
        self.selectUndistortedImagesPushButton.clicked.connect(self.selectUndistortedImages)
        self.numberOfUndistortedImagesLineEdit.setText("0")
        self.addUndistortedImagesProcessPushButton.clicked.connect(self.addUndistortedImageFiles)
        # Metashape project type
        self.selectImagesMpPushButton.clicked.connect(self.selectImages)
        self.numberOfImagesMpLineEdit.setText("0")
        self.addImagesProcessMpPushButton.clicked.connect(self.addImageFiles)
        self.selectUndistortedImagesMpPushButton.clicked.connect(self.selectUndistortedImages)
        self.numberOfUndistortedImagesMpLineEdit.setText("0")
        self.addUndistortedImagesProcessMpPushButton.clicked.connect(self.addUndistortedImageFiles)
        self.updateImagesDataPushButton.clicked.connect(self.updateImagesData)
        # self.numberOfSelectedProjectImagesMpLineEdit.setText("0")

        # create
        self.createProjectPushButton.clicked.connect(self.createProject)

        # Methashape Markers XML file
        self.selectMetashapeFilePushButton.clicked.connect(self.selectMetashapeMarkersXmlFile)
        self.selectMetashapeCodePushButton.clicked.connect(self.selectMetashapeCode)
        # self.selectMetashapeChunkPushButton.clicked.connect(self.selectMetashapeChunk)
        # self.metashapeChunkLineEdit.setText(PTDefinitions.CONST_METASHAPE_CHUNK_DEFAULT_VALUE)
        # self.metashapeCodeLineEdit.setText(PTDefinitions.CONST_METASHAPE_CODE_DEFAULT_VALUE)
        self.metashapeChunkComboBox.setEnabled(False)
        self.metashapeProcessPushButton.clicked.connect(self.addToProjectFromMetashapeMarkersXmlFile)
        self.importOriGroupBox.setEnabled(False)
        self.importUndistortedImagesGroupBox.setEnabled(False)
        self.centeredPPACheckBox.setChecked(False)
        self.centeredPPACheckBox.setEnabled(False)
        # Metashape project type
        self.selectMetashapeFileMpPushButton.clicked.connect(self.selectMetashapeMarkersXmlFile)
        self.selectMetashapeCodeMpPushButton.clicked.connect(self.selectMetashapeCode)
        # self.selectMetashapeChunkPushButton.clicked.connect(self.selectMetashapeChunk)
        # self.metashapeChunkLineEdit.setText(PTDefinitions.CONST_METASHAPE_CHUNK_DEFAULT_VALUE)
        # self.metashapeCodeLineEdit.setText(PTDefinitions.CONST_METASHAPE_CODE_DEFAULT_VALUE)
        self.metashapeChunkMpComboBox.setEnabled(False)
        self.metashapeProcessMpPushButton.clicked.connect(self.addToProjectFromMetashapeMarkersXmlFile)
        self.importOriMpGroupBox.setEnabled(False)
        self.importUndistortedImagesMpGroupBox.setEnabled(False)

        # temporal path
        self.pmTemporalPathPushButton.clicked.connect(self.selectProjectManagerTemporalPath)
        self.pmOutputPathPushButton.clicked.connect(self.selectProjectManagerOutputPath)

        self.getProcessingToolsCommands()
        self.processingToolsCommandParamtersPushButton.clicked.connect(self.selectProcessingToolsCommandParameters)
        self.processingToolsCommandPushButton.clicked.connect(self.selectProcessingToolsCommandProcess)

        # Test measurements
        self.photogrammetryToolBox.currentChanged.connect(self.onChangeToolBox)
        if self.enableMeasurements:
            self.measurementsGroupBox.setEnabled(True)
        else:
            self.measurementsGroupBox.setEnabled(False)
        self.measurementsParametersPushButton.clicked.connect(self.selectMeasurementsParameters)
        self.measurementsProcessPushButton.clicked.connect(self.selectMeasurementsProcess)

        # Current layer and it't parameters
        self.__layer = None
        self.__layergeometryType = None
        self.__layerwkbType = None
        self.__hasZ = False
        self.__hasM = False
        self.__isMultiType = False
        self.__isEditMode = False

        self.canvas = self.iface.mapCanvas()

        projectCrsId = self.canvas.mapSettings().destinationCrs().srsid()
        self.highLighter = HighlightFeature(self.canvas,
                                            True,
                                            False,
                                            projectCrsId)

        ###################################################
        # Digitizing Tool
        ###################################################

        self.action_digitize_feature = QAction(QIcon(":/plugins/photogrammetry_tools/icons/mActionToggleEditing.svg"),
                                               "Create")
        self.action_digitize_feature.setCheckable(True)
        self.action_digitize_feature.triggered.connect(self.digitize_feature)
        self.digitizing_toolbar = self.iface.addToolBar("PH digitizing")
        self.digitizing_toolbar.addAction(self.action_digitize_feature)
        self.addw = QgsAdvancedDigitizingDockWidget(self.iface.mapCanvas())
        self.tool_digitize_feature = QgsPhToolDigitizeFeature(self.iface.mapCanvas(), self.addw)  # false = in
        self.tool_digitize_feature.setAction(self.action_digitize_feature)

        self.tool_digitize_feature.digitizingCompleted.connect(self.ondigitizingCompleted)
        self.tool_digitize_feature.canvasPressSignal.connect(self.onCanvasPressSignal)
        self.tool_digitize_feature.deactivated.connect(self.onDigitizeToolDeactivate)
        self.canvas.currentLayerChanged.connect(self.toggle)

        ###################################################
        # Photogrammetric vertex edition tool
        ###################################################
        self.action_edit_vertex = QAction(QIcon(":/plugins/photogrammetry_tools/icons/mActionToggleEditing.svg"),
                                               "Edit")
        self.action_edit_vertex.setCheckable(True)
        self.action_edit_vertex.triggered.connect(self.edit_vertex)
        self.digitizing_toolbar.addAction(self.action_edit_vertex)
        self.tool_edit_vertex = QgsPhToolEditVertex(self.iface.mapCanvas())
        self.tool_edit_vertex.setAction(self.action_edit_vertex)
        self.tool_edit_vertex.canvasClicked.connect(self.onEditVertexClicked)
        self.tool_edit_vertex.deactivated.connect(self.onEditVertexToolDeactivate)
        ######################################################################

    def __setlayerproperties(self):
        self.__layergeometryType = self.__layer.geometryType()
        self.__layerwkbType = self.__layer.wkbType()
        self.__hasZ = QgsWkbTypes.hasZ(self.__layerwkbType)
        self.__hasM = QgsWkbTypes.hasM(self.__layerwkbType)
        self.__isMultiType = QgsWkbTypes.isMultiType(self.__layerwkbType)

    def toggle(self):
        """ When current layer changed  """
        self.__layer = self.canvas.currentLayer()
        # Decide whether the plugin button/menu is enabled or disabled
        if self.__layer is not None:
            if self.__layer.type() == QgsMapLayer.VectorLayer:
                self.__setlayerproperties()

                if self.__layer.isEditable() and (
                        self.__layergeometryType == QgsWkbTypes.PointGeometry
                        or self.__layergeometryType == QgsWkbTypes.LineGeometry
                        or self.__layergeometryType == QgsWkbTypes.PolygonGeometry):
                    self.__layer.editingStopped.connect(self.toggle)
                    try:
                        self.__layer.editingStarted.disconnect(self.toggle)
                    except Exception:
                        pass
                else:
                    self.__layer.editingStarted.connect(self.toggle)
                    try:
                        self.__layer.editingStopped.disconnect(self.toggle)
                    except Exception:
                        pass

    def loadImagesPcLayer(self):
        imagesPcTableName = None
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            imagesPcTableName = PTDefinitions.CONST_SPATIALITE_LAYERS_IMAGES_PC_TABLE_NAME
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            imagesPcTableName = PTDefinitions.CONST_SPATIALITE_LAYERS_IMAGES_PC_TABLE_NAME_GENERIC_PROJECT
        layerList = QgsProject.instance().mapLayersByName(imagesPcTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = imagesPcTableName
            geom_column = PTDefinitions.CONST_SPATIALITE_LAYERS_IMAGES_PC_TABLE_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = imagesPcTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlImagesPcFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + imagesPcTableName
                                   +" into QGIS")
                msgBox.exec_()

    def loadROIsLayer(self):
        roisTableName = PTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(roisTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = roisTableName
            geom_column = PTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = roisTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlRoisFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + roisTableName
                                   +" into QGIS")
                msgBox.exec_()

    def onChangeToolBox(self):
        self.measurementsChunksComboBox.clear()
        index = self.photogrammetryToolBox.currentIndex()
        if index == 0:
            return
        connectionFileName = self.projectsComboBox.currentText()
        if connectionFileName == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project before")
            msgBox.exec_()
            return
        connectionPath = self.connections[connectionFileName]
        ret = self.iPyProject.ptGetChunks(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        chunks = ret[1]
        if len(chunks) == 0:
            return
        elif len(chunks) > 1:
            self.measurementsChunksComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
        for chunk in chunks:
            self.measurementsChunksComboBox.addItem(chunk)

    def openProject(self):
        self.closeProjectPushButton.setEnabled(False)
        self.existsOrientations = False
        self.processingToolsPage.setEnabled(False)
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        self.numberOfImagesInProject = 0
        self.projectManagementTabWidget.setTabEnabled(1, False)
        self.projectManagementTabWidget.setTabEnabled(2, False)
        connectionFileName = self.projectsComboBox.currentText()
        if connectionFileName == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project before")
            msgBox.exec_()
            return
        connectionPath = self.connections[connectionFileName]
        ret = self.iPyProject.ptOpenProject(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return

        pt_parameters = self.iPyProject.ptGetProcessingToolsCommandParameters('Object point measurement')
        if pt_parameters[0] == "True":
            self.tool_digitize_feature.parameters = pt_parameters[1]

        ret = self.iPyProject.ptGetProjectType(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.projectType = ret[1]
        self.projectType = self.projectType.lower()
        self.dbFileName = connectionPath
        groupName = PTDefinitions.CONST_LAYER_TREE_PROJECT_NAME
        self.layerTreeProjectName = groupName + connectionFileName
        root = QgsProject.instance().layerTreeRoot()
        self.layerTreeProject = root.addGroup(self.layerTreeProjectName)
        self.loadROIsLayer()
        self.loadImagesPcLayer()
        # self.loadTilesLayer()
        self.closeProjectPushButton.setEnabled(True)
        self.openProjectPushButton.setEnabled(False)
        self.projectsComboBox.setEnabled(False)
        self.projectManagementTabWidget.setEnabled(True)
        self.projectManagementTabWidget.setTabEnabled(0, False)

        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            self.projectManagementTabWidget.setTabEnabled(1, True)
            self.projectManagementTabWidget.setTabEnabled(2, False)
            self.importOriMpGroupBox.setEnabled(True)
            self.importImagesMpGroupBox.setEnabled(True)
            self.importUndistortedImagesMpGroupBox.setEnabled(True)
            # self.metashapeChunkLineEdit.setText(PTDefinitions.CONST_METASHAPE_CHUNK_DEFAULT_VALUE)
            self.metashapeFileMpLineEdit.clear()
            self.metashapeChunkMpComboBox.clear()
            self.metashapeChunkMpComboBox.setEnabled(False)
            self.metashapeCodeMpLineEdit.setText(PTDefinitions.CONST_METASHAPE_CODE_DEFAULT_VALUE)
            ret = self.iPyProject.ptGetExistsOrientations(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.existsOrientations = ret[1]
            if self.existsOrientations:
                self.processingToolsPage.setEnabled(True)
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            self.projectManagementTabWidget.setTabEnabled(1, False)
            self.projectManagementTabWidget.setTabEnabled(2, True)
            self.importOriGroupBox.setEnabled(False)
            self.importUndistortedImagesGroupBox.setEnabled(False)
            # self.metashapeChunkLineEdit.setText(PTDefinitions.CONST_METASHAPE_CHUNK_DEFAULT_VALUE)
            self.metashapeChunkComboBox.clear()
            self.metashapeChunkComboBox.setEnabled(False)
            self.metashapeCodeLineEdit.setText(PTDefinitions.CONST_METASHAPE_CODE_DEFAULT_VALUE)
            ret = self.iPyProject.ptGetNumberOfImages(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.numberOfImagesInProject = ret[1]
            if self.numberOfImagesInProject > 0:
                self.importOriGroupBox.setEnabled(True)
                self.importUndistortedImagesGroupBox.setEnabled(True)
            ret = self.iPyProject.ptGetExistsOrientations(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.existsOrientations = ret[1]
            if self.existsOrientations:
                self.processingToolsPage.setEnabled(True)
            return

        tilesTableName = PTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_NAME
        # layerList = QgsProject.instance().mapLayersByName(tilesTableName)
        # if not layerList:
        #     self.projectManagementTabWidget.setTabEnabled(2, False)
        # else:
        #     tilesLayer = layerList[0]
        #     if tilesLayer.featureCount() > 0:
        #         self.projectManagementTabWidget.setTabEnabled(2, True)
        # self.manualEditingProcessesPage.setEnabled(True)
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Process completed successfully")
        # msgBox.exec_()

    # def selectMetashapeChunk(self):
    #     oldText = self.metashapeChunkLineEdit.text()
    #     label = "Input metashape chunk:"
    #     title = PTDefinitions.CONST_PROGRAM_TITLE
    #     [text, ok] = QInputDialog.getText(self, title, label, QLineEdit.Normal, oldText)
    #     if ok and text:
    #         text = text.strip()
    #         if not text == oldText:
    #             self.metashapeChunkLineEdit.setText(text)
    #     return

    def selectMeasurementsParameters(self):
        command = PTDefinitions.CONST_MEASUREMENTS_COMMAND
        ret = self.iPyProject.ptSelectProcessingToolsCommandParameters(command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        return

    def selectMeasurementsProcess(self):
        connectionFileName = self.projectsComboBox.currentText()
        if connectionFileName == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project before")
            msgBox.exec_()
            return
        connectionPath = self.connections[connectionFileName]
        chunk = self.measurementsChunksComboBox.currentText()
        if chunk == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select chunk before")
            msgBox.exec_()
            return
        useDsm = True;
        # Ejemplo para obtener las proyecciones aproximadas a partir de un punto objeto
        pointCoordinates = []
        pointCoordinates.append(379937.215)
        pointCoordinates.append(4064389.632)
        # pointCoordinates.append(52.071)  La altitud se puede obtener del MDS
        # hay que recuperar el codigo epsg del crs de la posicion
        # que entiendo sera el del proyecto
        # hay una signal de cuando cambia el crs de un proyecto: crsChanged
        crs = QgsProject.instance().crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        # crsOsr = osr.SpatialReference()  # define test1
        # if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
        #     msgBox.exec_()
        #     return
        # if not crsOsr.IsProjected():
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Selected CRS is not a projected CRS")
        #     msgBox.exec_()
        #     return
        # crsEpsgCode = 25830
        ret = self.iPyProject.ptGetProjectedImagesFromObjectPoint(connectionPath,
                                                                  chunk,
                                                                  crsEpsgCode,
                                                                  pointCoordinates,
                                                                  useDsm)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        projectedImages = ret[1]
        text = "Object Point = \n"
        text += ("- Easting .... = " + str(pointCoordinates[0]) + "\n")
        text += ("- Northing ... = " + str(pointCoordinates[1]) + "\n")
        # text += ("- Height ..... = " + str(objectPoint[2]) + "\n")
        text += "Projection in images = \n"
        imageLabels = projectedImages.keys()
        for imageLabel in imageLabels:
            text += ("- Image ...... = " + imageLabel + "\n")
            values = projectedImages[imageLabel]
            text += ("  - Column ... = " + str(values[0]) + "\n")
            text += ("  - Row ...... = " + str(values[1]) + "\n")
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Projected images from object Point:\n"+text)
        msgBox.exec_()

        # Ejemplo de llamada a partir de la medicion en una imagen
        measurements = {}
        measurements["DSC05749.JPG"] = [2892.0,1951.0]
        ret = self.iPyProject.ptGetObjectPointProjectedImagesFromMeasuredImages(connectionPath,
                                                                                chunk,
                                                                                useDsm,
                                                                                measurements)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        objectPoint = ret[1]
        projectedImages = ret[2]
        text = "Object Point = \n"
        text += ("- Easting .... = " + str(objectPoint[0]) + "\n")
        text += ("- Northing ... = " + str(objectPoint[1]) + "\n")
        text += ("- Height ..... = " + str(objectPoint[2]) + "\n")
        text += "Projection in images = \n"
        imageLabels = projectedImages.keys()
        for imageLabel in imageLabels:
            text += ("- Image ...... = " + imageLabel + "\n")
            values = projectedImages[imageLabel]
            text += ("  - Column ... = " + str(values[0]) + "\n")
            text += ("  - Row ...... = " + str(values[1]) + "\n")
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Object Point from measured images:\n"+text)
        msgBox.exec_()

        return

    def selectMetashapeCode(self):
        oldText = None
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            oldText = self.metashapeCodeMpLineEdit.text()
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            oldText = self.metashapeCodeLineEdit.text()
        label = "Input code:"
        title = PTDefinitions.CONST_PROGRAM_TITLE
        [text, ok] = QInputDialog.getText(self, title, label, QLineEdit.Normal, oldText)
        if ok and text:
            text = text.strip()
            if not text == oldText:
                if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
                    self.metashapeCodeMpLineEdit.setText(text)
                elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
                    self.metashapeCodeLineEdit.setText(text)
        return

    def selectMetashapeMarkersXmlFile(self):
        oldFileName = None
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            oldFileName = self.metashapeFileMpLineEdit.text()
            self.metashapeChunkMpComboBox.clear()
            self.metashapeChunkMpComboBox.setEnabled(False)
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            oldFileName = self.metashapeFileLineEdit.text()
            self.metashapeChunkComboBox.clear()
            self.metashapeChunkComboBox.setEnabled(False)
        title="Select Metashape Markers XML file (.xml)"
        filters="XML files (*.xml)"
        fileName, _ = QFileDialog.getOpenFileName(self,title,self.path,filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
            chunks = self.iPyProject.ptGetChunksFromMetashapeMarkersXmlFile(fileName)
            if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
                self.metashapeFileMpLineEdit.setText(fileName)
                # self.metashapeChunkLineEdit.setText(PTDefinitions.CONST_METASHAPE_CHUNK_DEFAULT_VALUE)
                self.metashapeChunkMpComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
                for chunk in chunks:
                    self.metashapeChunkMpComboBox.addItem(chunk)
                if len(chunks) > 0:
                    self.metashapeChunkMpComboBox.setEnabled(True)
                if len(chunks) == 1:
                    self.metashapeChunkMpComboBox.setCurrentIndex(1)
                    self.metashapeChunkMpComboBox.setEnabled(False)
            elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
                self.metashapeFileLineEdit.setText(fileName)
                # self.metashapeChunkLineEdit.setText(PTDefinitions.CONST_METASHAPE_CHUNK_DEFAULT_VALUE)
                self.metashapeChunkComboBox.addItem(PTDefinitions.CONST_NO_COMBO_SELECT)
                for chunk in chunks:
                    self.metashapeChunkComboBox.addItem(chunk)
                if len(chunks) > 0:
                    self.metashapeChunkComboBox.setEnabled(True)
                if len(chunks) == 1:
                    self.metashapeChunkComboBox.setCurrentIndex(1)
                    self.metashapeChunkComboBox.setEnabled(False)
        return

    def selectNewDatabase(self):
        oldFileName=self.databaseLineEdit.text()
        title="Select New Project File (.sqlite)"
        filters="Project Files (*.sqlite)"
        fileName, _ = QFileDialog.getSaveFileName(self,title,self.path,filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.databaseLineEdit.setText(fileName)
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
        return

    def removeGroup(self,root,name):
        # root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

    def selectImages(self):
        previousFiles = self.imageFiles[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         PTDefinitions.CONST_SELECT_IMAGES_FILES_DIALOG_TITLE,
                                         self.imageFilesFileTypes,
                                         self.imageFiles,
                                         self.imageFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.imageFiles = []
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            self.numberOfImagesMpLineEdit.setText("0")
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            self.numberOfImagesLineEdit.setText("0")
        # simplifico porque tarda
        for file in files:
            self.imageFiles.append(file)
        # for file in files:
        #     fileBaseName = QFileInfo(file).baseName()
        #     findFile = False
        #     for imageFile in self.imageFiles:
        #         if fileBaseName == QFileInfo(imageFile).baseName():
        #             findFile = True
        #             break
        #     if not findFile:
        #         self.imageFiles.append(file)
        self.imageFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            self.numberOfImagesMpLineEdit.setText(str(len(self.imageFiles)))
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            self.numberOfImagesLineEdit.setText(str(len(self.imageFiles)))
        return

    def selectProcessingToolsCommandParameters(self):
        command = self.processingToolsCommandComboBox.currentText()
        if command == PTDefinitions.CONST_NO_COMBO_SELECT:
            return
        dbFileName = self.connections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        # ret = self.iPyProject.mmtSelectPointCloudCommandParameters(dbFileName,command)
        ret = self.iPyProject.ptSelectProcessingToolsCommandParameters(command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        return

    def selectProcessingToolsCommandProcess(self):
        dbFileName = self.connections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        command = self.processingToolsCommandComboBox.currentText()
        if command == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select command to process")
            msgBox.exec_()
            return
        # selectedPointCloudConnectionInProject = self.pointCloudsComboBox.currentText()
        # if selectedPointCloudConnectionInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Select point ploud")
        #     msgBox.exec_()
        #     return
        # pointCloudSpatialiteDbFileName = self.pointCloudConnectionsInProject[selectedPointCloudConnectionInProject]
        # ret = self.iPyProject.mmtProcessPointCloudCommand(dbFileName,command,pointCloudSpatialiteDbFileName)
        initialDateTime = QDateTime.currentDateTime()
        ret = self.iPyProject.ptProcessProcessingToolsCommand(dbFileName,command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        else:
            finalDateTime = QDateTime.currentDateTime()
            initialSeconds = initialDateTime.toTime_t()
            finalSeconds = finalDateTime.toTime_t()
            totalDurationSeconds = finalSeconds - initialSeconds
            durationDays = floor(totalDurationSeconds / 60.0 / 60.0 / 24.0)
            durationHours = floor((totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0) / 60.0 / 60.0)
            durationMinutes = floor((totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0 - durationHours * 60.0 * 60.0) / 60.0)
            durationSeconds = totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0 - durationHours * 60.0 * 60.0 - durationMinutes * 60.0
            msgTtime = "- Process time:\n"
            msgTtime += "  - Start time of the process ......................: "
            msgTtime += initialDateTime.toString("yyyy/MM/dd - hh/mm/ss.zzz")
            msgTtime += "\n"
            msgTtime += "  - End time of the process ........................: "
            msgTtime += finalDateTime.toString("yyyy/MM/dd - hh/mm/ss.zzz")
            msgTtime += "\n"
            msgTtime += "  - Number of total seconds ........................: "
            msgTtime += f"{totalDurationSeconds:.3f}" # QString.number(totalDurationSeconds, 'f', 3)
            msgTtime += "\n"
            msgTtime += "    - Number of days ...............................: "
            msgTtime += str(durationDays) # QString.number(durationDays)
            msgTtime += "\n"
            msgTtime += "    - Number of hours ..............................: "
            msgTtime += str(durationHours) # QString.number(durationHours)
            msgTtime += "\n"
            msgTtime += "    - Number of minutes ............................: "
            msgTtime += str(durationMinutes) # QString.number(durationMinutes)
            msgTtime += "\n"
            msgTtime += "    - Number of seconds ............................: "
            msgTtime += f"{durationSeconds:.3f}" # QString.number(durationSeconds, 'f', 3)
            msgTtime += "\n"
            msg = "Process completed successfully"
            msg += "\n"
            msg += msgTtime
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText(msg)
            msgBox.exec_()
        return

    def selectProject(self):
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        projectFileName = self.projectsComboBox.currentText()
        if projectFileName == PTDefinitions.CONST_NO_COMBO_SELECT:
            self.projectManagementTabWidget.setEnabled(True)
            self.projectManagementTabWidget.setTabEnabled(0, True)
            self.projectManagementTabWidget.setTabEnabled(1, False)
            self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(0)
            if self.dbFileName:
                self.closeProject()
        else:
            self.projectManagementTabWidget.setEnabled(False)
            # self.projectManagementTabWidget.setTabEnabled(0, False)
            # self.projectManagementTabWidget.setTabEnabled(1, False)
            # self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(1)
            self.openProjectPushButton.setEnabled(True)
            self.closeProjectPushButton.setEnabled(False)
        return

    def selectProjectManagerOutputPath(self):
        strDir = QFileDialog.getExistingDirectory(self, "Select directory", self.projectManagerOutputPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.ptSetProjectManagerOutputPath(self.projectManagerOutputPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmOutputPathLineEdit.setText("")
                self.projectManagerOutputPath = None
                return
            self.projectManagerOutputPath = strDir
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
            self.pmOutputPathLineEdit.setText(strDir)
        return

    def selectProjectManagerTemporalPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory", self.projectManagerTemporalPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.ptSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmTemporalPathLineEdit.setText("")
                self.projectManagerTemporalPath = None
                return
            self.projectManagerTemporalPath = strDir
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
            self.pmTemporalPathLineEdit.setText(strDir)
        return

    def selectProjectParameters(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == PTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type before")
            msgBox.exec_()
            return
        ret = self.iPyProject.ptSelectProjectParameters(projectType)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        return

    def selectProjectType(self):
        projectType = self.projectTypeComboBox.currentText()
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Project type: "+projectType)
        # msgBox.exec_()
        return

    def selectRois(self):
        previousFiles = self.roisShapefiles[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         PTDefinitions.CONST_SELECT_ROIS_SHAPEFILES_DIALOG_TITLE,
                                         self.roisFileTypes,
                                         self.roisShapefiles,
                                         self.roisFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.roisShapefiles = []
        self.numberOfRoisLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for roiFile in self.roisShapefiles:
                if fileBaseName == QFileInfo(roiFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.roisShapefiles.append(file)
        self.roisFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        self.numberOfRoisLineEdit.setText(str(len(self.roisShapefiles)))
        return

    def selectUndistortedImages(self):
        previousFiles = self.undistortedImageFiles[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         PTDefinitions.CONST_SELECT_IMAGES_FILES_DIALOG_TITLE,
                                         self.imageFilesFileTypes,
                                         self.undistortedImageFiles,
                                         self.imageFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.undistortedImageFiles = []
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            self.numberOfUndistortedImagesMpLineEdit.setText("0")
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            self.numberOfUndistortedImagesLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for imageFile in self.undistortedImageFiles:
                if fileBaseName == QFileInfo(imageFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.undistortedImageFiles.append(file)
        self.imageFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        if self.projectType == PTDefinitions.CONST_PROJECT_TYPE_METASHAPE:
            self.numberOfUndistortedImagesMpLineEdit.setText(str(len(self.undistortedImageFiles)))
        elif self.projectType == PTDefinitions.CONST_PROJECT_TYPE_GENERIC:
            self.numberOfUndistortedImagesLineEdit.setText(str(len(self.undistortedImageFiles)))
        return

    def updateImagesData(self):
        return

    def openDigitizngUI(self, digitizing_point_id, list_projected_images):
        connection_file_name = self.projectsComboBox.currentText()
        connection_path = self.connections[connection_file_name]
        if not self.image_paths:
            ret = self.iPyProject.ptGetImagesPathFromImagesLabel(connection_path, 'chunk 1')
            if not (ret[0] == 'False'):
                self.image_paths = ret[1]

        self.pht_images_widget = PhToolsQImagesWidget(self.iface, connection_path, digitizing_point_id,
                                                      self.image_paths, list_projected_images, self.iPyProject,
                                                      self.pt_qt_project, self.tool_digitize_feature)
        self.pht_images_widget.debugTextGenerated.connect(self.onDebugTextGenerated)
        self.pht_images_dock = QDockWidget("Images")
        self.pht_images_dock.setWidget(self.pht_images_widget)
        self.iface.addDockWidget(Qt.RightDockWidgetArea, self.pht_images_dock)

        self.pht_images_widget.newVertexCoords.connect(self.onNewVertexCoordinates)

    def digitize_feature(self):
        self.iface.mapCanvas().setMapTool(self.tool_digitize_feature)

    def edit_vertex(self):
        self.iface.mapCanvas().setMapTool(self.tool_edit_vertex)

    def createCoords(self, coords, feature):
        """
        :param coords: reference at empty list
        :param feature: reference at QgsFeature
        :return: none
        """
        geom = feature.geometry()
        if self.__layergeometryType == QgsWkbTypes.PointGeometry:
            coords.append(['1', list()])
            if self.__isMultiType:
                for part in geom.constParts():
                    for vertex in part.vertices():
                        row = list([vertex.x(), vertex.y()])
                        if self.__hasZ:
                            row.append(vertex.z())
                        if self.__hasM:
                            row.append(vertex.m())
                        coords[0][1].append(row)
            else:
                for vertex in geom.vertices():
                    row = list([vertex.x(), vertex.y()])
                    if self.__hasZ:
                        row.append(vertex.z())
                    if self.__hasM:
                        row.append(vertex.m())
                    coords[0][1].append(row)

        elif self.__layergeometryType == QgsWkbTypes.LineGeometry:
            if self.__isMultiType:
                part_num = 0
                for part in geom.constParts():
                    coords.append([str(part_num + 1), list()])
                    for vertex in part.vertices():
                        row = list([vertex.x(), vertex.y()])
                        if self.__hasZ:
                            row.append(vertex.z())
                        if self.__hasM:
                            row.append(vertex.m())
                        coords[part_num][1].append(row)
                    part_num = part_num + 1
            else:
                coords.append(['1', list()])
                for vertex in geom.vertices():
                    row = list([vertex.x(), vertex.y()])
                    if self.__hasZ:
                        row.append(vertex.z())
                    if self.__hasM:
                        row.append(vertex.m())
                    coords[0][1].append(row)

        elif self.__layergeometryType == QgsWkbTypes.PolygonGeometry:
            # if self.__isMultiType:
            part_num = 0
            ring_num = 0
            for part in geom.constParts():
                ring = part.exteriorRing()
                coords.append([str(part_num + 1), list()])
                for vertex in ring.vertices():
                    row = list([vertex.x(), vertex.y()])
                    if self.__hasZ:
                        row.append(vertex.z())
                    if self.__hasM:
                        row.append(vertex.m())
                    coords[part_num + ring_num][1].append(row)

                # If first and last point identical - remove last point
                part_list = coords[part_num + ring_num][1]
                if part_list[0][0] == part_list[len(part_list) - 1][0] and \
                        part_list[0][1] == part_list[len(part_list) - 1][1]:
                    del part_list[-1]

                part_num = part_num + 1

                intrings = part.numInteriorRings()
                for i in range(intrings):
                    ring = part.interiorRing(i)
                    coords.append([str(-(ring_num + 1)), list()])
                    for vertex in ring.vertices():
                        row = list([vertex.x(), vertex.y()])
                        if self.__hasZ:
                            row.append(vertex.z())
                        if self.__hasM:
                            row.append(vertex.m())
                        coords[part_num + ring_num][1].append(row)

                    # If first and last point identical - remove last point
                    part_list = coords[part_num + ring_num][1]
                    if part_list[0][0] == part_list[len(part_list) - 1][0] and \
                            part_list[0][1] == part_list[len(part_list) - 1][1]:
                        del part_list[-1]

                    ring_num = ring_num + 1

    def ondigitizingCompleted(self, feature):
        layer = self.iface.activeLayer()
        layer.addFeature(feature)
        if self.tool_digitize_feature.mode() == 1:  # CapturePoint
            # if self.selectedFeature:
                # layer.deselect(self.selectedFeature.id())
            self.selectedFeature = feature
            # layer.select(feature.id())

            if self.highLighter:
                self.highLighter.removeHighlight()
                coords = list()
                self.createCoords(coords, feature)
                self.featureCrsId = layer.crs().srsid()
                self.highLighter.createHighlight(coords, 0, self.featureCrsId)
                self.highLighter.changeCurrentVertex(0)

    def onNewVertexCoordinates(self, point):
        # import pydevd_pycharm
        # pydevd_pycharm.settrace('localhost', port=54100, stdoutToServer=True, stderrToServer=True)
        #TODO: Not only points....
        if self.selectedFeature:
            if self.tool_digitize_feature.mode() == 1:  # CapturePoint
                self.selectedFeature.setGeometry(QgsPoint(point))
                self.iface.activeLayer().updateFeature(self.selectedFeature)
                self.canvas.refresh()

                if self.highLighter:
                    self.highLighter.removeHighlight()
                    layer = self.iface.activeLayer()
                    coords = list()
                    self.createCoords(coords, self.selectedFeature)
                    self.featureCrsId = layer.crs().srsid()
                    self.highLighter.createHighlight(coords, 0, self.featureCrsId)
                    self.highLighter.changeCurrentVertex(0)
            else:
                # import pydevd_pycharm
                # pydevd_pycharm.settrace('localhost', port=54100, stdoutToServer=True, stderrToServer=True)
                geometry = self.selectedFeature.geometry()
                geometry.moveVertex(point.x(), point.y(), self.selected_vertex)
                self.selectedFeature.setGeometry(geometry)
                layer = self.iface.activeLayer()
                layer.beginEditCommand("Feature updated")
                layer.updateFeature(self.selectedFeature)
                layer.endEditCommand()
                # self.__layer.beginEditCommand("Feature updated")
                # self.__layer.updateFeature(self.selectedFeature)
                # self.__layer.endEditCommand()
                self.canvas.refresh()
                if self.highLighter:
                    self.highLighter.removeHighlight()
                    layer = self.iface.activeLayer()
                    coords = list()
                    self.createCoords(coords, self.selectedFeature)
                    self.featureCrsId = layer.crs().srsid()
                    self.highLighter.createHighlight(coords, 0, self.featureCrsId)
                    self.highLighter.changeCurrentVertex(self.selected_vertex)


    def onDigitizeToolDeactivate(self):
        if self.highLighter:
            self.highLighter.removeHighlight()
            # self.highLighter.changeCurrentVertex(-1)

    def onEditVertexToolDeactivate(self):
        if self.highLighter:
            self.highLighter.removeHighlight()

    def onCanvasPressSignal(self, mouse_event):
        if mouse_event.button() == Qt.RightButton:
            pass
            # ret = self.iPyProject.ptGetProjectedImagesFromObjectPoint(connectionPath,
            #                                                           'chunk 1',
            #                                                           crsEpsgCode,
            #                                                           point_coordinates,
            #                                                           True)
            # if not (ret[0] == 'False'):
            #     projected_images = ret[1]
            #     self.openDigitizngUI(projected_images)

        elif mouse_event.button() == Qt.LeftButton:
            self.loadPhMeasureCanvas(mouse_event.mapPoint())

        mouse_event.accept()


    def loadPhMeasureCanvas(self, point):
        crs = QgsProject.instance().crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle("---")
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:', ''))

        connectionFileName = self.projectsComboBox.currentText()
        connectionPath = self.connections[connectionFileName]

        point_coordinates = []
        point_coordinates.append(point.x())
        point_coordinates.append(point.y())

        logging.warning('#')
        logging.warning('i_py_project.ptAddObjectPoint({},{},{},{},{})'.format(
            connectionPath, 'chunk 1',
            crsEpsgCode, point_coordinates, True))
        ret = self.iPyProject.ptAddObjectPoint(connectionPath, 'chunk 1', crsEpsgCode, point_coordinates, True)
        logging.warning(str(ret))
        if not (ret[0] == 'False'):
            point_id = ret[1]
            logging.warning('#')
            logging.warning('i_py_project.ptGetObjectPointProjectedImages({},{},{},{},{},[])'.format(
                connectionPath, 'chunk 1', point_id,
                crsEpsgCode, True))
            ret = self.iPyProject.ptGetObjectPointProjectedImages(connectionPath, 'chunk 1', point_id, crsEpsgCode,
                                                                  True, [])
            logging.warning(str(ret))
            projected_images = ret[5]

            self.openDigitizngUI(point_id, projected_images)


    def onEditVertexClicked(self, point):
        # import pydevd_pycharm
        # pydevd_pycharm.settrace('localhost', port=54100, stdoutToServer=True, stderrToServer=True)
        current_layer = self.canvas.currentLayer()  
        if current_layer.isEditable():
            #TODO: Snap de seleccin es fijo, buscar mejor estrategia (0.5m)
            request_rect = QgsRectangle(point.x()-0.5, point.y()-0.5, point.x()+0.5, point.y()+0.5)
            request = QgsFeatureRequest()
            request.setFilterRect(request_rect)
            request.setFlags(QgsFeatureRequest.ExactIntersect)
            request.setLimit(1)
            feature_list = list(current_layer.getFeatures(request))
            if len(feature_list):
                coords = list()
                self.createCoords(coords, feature_list[0])
                if len(coords):
                    self.featureCrsId = current_layer.crs().srsid()
                    if self.highLighter:
                        self.highLighter.removeHighlight()
                    self.highLighter.createHighlight(coords, 0, self.featureCrsId)
                    self.selected_vertex = 0
                    current_vertex = 0
                    distance = point.distance(coords[0][1][0][0], coords[0][1][0][1])
#
                    self.selectedFeature = feature_list[0]

                    for partNum in range(len(coords)):
                        partcoords = coords[partNum][1]
                        for coord in partcoords:
                            current_distance = point.distance(coord[0], coord[1])
                            if current_distance < distance:
                                distance = current_distance
                                self.selected_vertex = current_vertex
                            current_vertex = current_vertex + 1
                    self.highLighter.changeCurrentVertex(self.selected_vertex)
                    self.loadPhMeasureCanvas(point)
            else:
                if self.highLighter:
                    self.highLighter.removeHighlight()

    def onDebugTextGenerated(self, debug_str):
        self.debugTextEdit.append(debug_str)
